<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Demo - Cubic nonlinear Klein-Gordon equation">

<title>Demo - Cubic nonlinear Klein-Gordon equation</title>

<!-- Bootstrap style: bootstrap -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let pre tags for code blocks have the same color as the surroundings */
pre { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Table of contents',
               1,
               'table_of_contents',
               'table_of_contents'),
              ('The nonlinear Klein-Gordon equation', 1, None, '___sec0'),
              ('Model equation', 2, None, '___sec1'),
              ('Spectral Galerkin formulation',
               2,
               'sec:spectralgalerkin',
               'sec:spectralgalerkin'),
              ('Discretization', 2, None, '___sec3'),
              ('Implementation', 1, None, '___sec4'),
              ('Initialization', 2, None, '___sec5'),
              ('Runge-Kutta integrator', 2, 'sec:rk', 'sec:rk'),
              ('Complete solver', 2, 'sec:solver', 'sec:solver'),
              ('Bibliography', 1, None, '___sec8')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="kleingordon_bootstrap.html">Demo - Cubic nonlinear Klein-Gordon equation</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#table_of_contents" style="font-size: 80%;"><b>Table of contents</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;"><b>The nonlinear Klein-Gordon equation</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Model equation</a></li>
     <!-- navigation toc: --> <li><a href="#sec:spectralgalerkin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Spectral Galerkin formulation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;"><b>Implementation</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Initialization</a></li>
     <!-- navigation toc: --> <li><a href="#sec:rk" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Runge-Kutta integrator</a></li>
     <!-- navigation toc: --> <li><a href="#sec:solver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Complete solver</a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;"><b>Bibliography</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0000"></a>
<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Demo - Cubic nonlinear Klein-Gordon equation </h1></center>  <!-- document title -->

<p>
<!-- author(s): Mikael Mortensen -->

<center>
<b>Mikael Mortensen</b>  (<tt>mikaem at math.uio.no</tt>)
</center>

<p>
<!-- institution -->

<center><b>Department of Mathematics, University of Oslo.</b></center>
<br>
<p>
<center><h4>Apr 3, 2018</h4></center> <!-- date -->
<br>
<p>
<b>Summary.</b> This is a demonstration of how the Python module <a href="https://github.com/spectralDNS/shenfun" target="_self">shenfun</a> can be used to solve the time-dependent,
nonlinear Klein-Gordon equation, in a triply periodic domain. The demo is implemented in
a single Python file <a href="https://github.com/spectralDNS/shenfun/blob/master/demo/KleinGordon.py" target="_self">KleinGordon.py</a>, and it may be run
in parallel using MPI. The Klein-Gordon equation is solved using a mixed
formulation. The discretization, and some background on the spectral Galerkin
method is given first, before we turn to the actual details of the <code>shenfun</code>
implementation.

<p>
</div> <!-- end jumbotron -->

<h1 id="table_of_contents">
Table of contents</h2>

<p>
<a href="#___sec0"> The nonlinear Klein-Gordon equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Model equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:spectralgalerkin"> Spectral Galerkin formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> Discretization </a><br>
<a href="#___sec4"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> Initialization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:rk"> Runge-Kutta integrator </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:solver"> Complete solver </a><br>
<a href="#___sec8"> Bibliography </a><br>
</p>

<h1 id="___sec0" class="anchor">The nonlinear Klein-Gordon equation </h1>

<p>

<embed src="movies/KleinGordon.gif"  autoplay="false" loop="true"></embed>
<p><em>Movie showing the evolution of the solution \( u \) from Eq. <a href="#mjx-eqn-1">(1)</a>, in a slice through the center of the domain, computed with the code described in this demo. <div id="mov:kleingordon"></div></em></p>

<h2 id="___sec1" class="anchor">Model equation </h2>

<p>
The cubic nonlinear Klein-Gordon equation is a wave equation important for many
scientific applications such as solid state physics, nonlinear optics and
quantum field theory <a href="#abdul08">[1]</a>. The equation is given as

$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} = \nabla^2 u - \gamma(u - u|u|^2) \quad
\text{for} \, u \in
\Omega, \tag{1}
\end{equation}
$$

with initial conditions
$$
\begin{equation}
u(\boldsymbol{x}, t=0) = u^0 \quad \text{and} \quad \frac{\partial u(\boldsymbol{x},
t=0)}{\partial t} = u_t^0. \tag{2}
\end{equation}
$$

<p>
The spatial coordinates are here denoted as \( \boldsymbol{x} = (x, y, z) \), and
\( t \) is time. The parameter \( \gamma=\pm 1 \) determines whether the equations are focusing
(\( +1 \)) or defocusing (\( -1 \)) (in the movie we have used \( \gamma=1 \)). The domain \( \Omega=[-2\pi, 2\pi]^3 \) is triply
periodic and initial conditions will here be set as

$$
\begin{align}
u^0 &= 0.1 \exp \left( -\boldsymbol{x} \cdot \boldsymbol{x} \right), 
\tag{3}\\ 
u_t^0 &= 0.
\tag{4}
\end{align}
$$

<p>
We will solve these equations using a mixed formulation and a spectral Galerkin
method. The mixed formulation reads

$$
\begin{align}
\frac{\partial f}{\partial t} &= \nabla^2 u - \gamma (u - u|u|^2), \tag{5}\\ 
\frac{\partial u}{\partial t} &= f. \tag{6}
\end{align}
$$

<p>
The energy of the solution can be computed as
$$
E(u) = \int_{\Omega} \left( \frac{1}{2} f^2 + \frac{1}{2}|\nabla u|^2 +
\gamma(\frac{1}{2}u^2 - \frac{1}{4}u^4) \right)
$$

and it is crucial that this energy remains constant in time.

<p>
The movie (<a href="#mov:kleingordon">mov:kleingordon</a>) is showing the solution \( u \), computed with the
code shown in the bottom of Sec. <a href="#sec:solver">Complete solver</a>.

<h2 id="sec:spectralgalerkin" class="anchor">Spectral Galerkin formulation</h2>
The PDEs in <a href="#mjx-eqn-5">(5)</a> and <a href="#mjx-eqn-6">(6)</a> can be solved with many different
numerical methods. We will here use the <a href="https://github.com/spectralDNS/shenfun" target="_self">shenfun</a> software and this software makes use of
the spectral Galerkin method. Being a Galerkin method, we need to reshape the
governing equations into proper variational forms, and this is done by
multiplying  <a href="#mjx-eqn-5">(5)</a> and <a href="#mjx-eqn-6">(6)</a> with the complex conjugate of proper
test functions and then integrating
over the domain. To this end we use testfunction \( g\in H^1(\Omega) \) with
Eq. <a href="#mjx-eqn-5">(5)</a>  and  \( v \in
H^1(\Omega) \) with Eq. <a href="#mjx-eqn-6">(6)</a>, where \( H^1(\Omega) \) is the Hilbert space, and we obtain

$$
\begin{align}
\frac{\partial}{\partial t} \int_{\Omega} f\, \overline{g} \,dx &= \int_{\Omega}
\left(\nabla^2 u \, \overline{g}
- \gamma( u\, - u|u|^2) \, \overline{g} \right) \,dx, \tag{7} \\ 
\frac{\partial }{\partial t} \int_{\Omega} u\, \overline{v} \, dx &=
\int_{\Omega} f\, \overline{v} \, dx. \tag{8}
\end{align}
$$

Note that the overline is used to indicate a complex conjugate. The functions \( f \) and \( u \) are now
to be considered as trial functions, and the integrals over the
domain are often referred to as inner products. With inner product notation

$$
\left(u, v\right) = \int_{\Omega} u \, \overline{v} \, dx.
$$

and an integration by parts on the Laplacian, the spatially discretized variational problem can be
formulated as: Find \( (u, f) \in H^1(\Omega) \times H^1(\Omega) \) such that
$$
\begin{align}
\frac{\partial}{\partial t} (f, g) &= -(\nabla u, \nabla g)
-\gamma \left( u - u|u|^2, g \right), \tag{9} \\ 
\frac{\partial }{\partial t} (u, v) &= (f, v) \quad \forall \, (v,g) \in
H^1(\Omega) \times H^1(\Omega). \tag{10}
\end{align}
$$

<p>
The time discretization is
still left open. There are numerous different approaches that one could take for
discretizing in time, and the first two terms on the right hand side of
<a href="#mjx-eqn-9">(9)</a> can easily be treated implicitly as well as explicitly. However,
the approach we will follow in Sec. (<a href="#sec:rk">Runge-Kutta integrator</a>) is a fully explicit 4th order <a href="https://en.wikipedia.org/wiki/Runge-Kutta_methods" target="_self">Runge-Kutta</a> method.

<h2 id="___sec3" class="anchor">Discretization </h2>
To find a numerical solution we need to discretize the continuous problem
<a href="#mjx-eqn-9">(9)</a> and <a href="#mjx-eqn-10">(10)</a> in space as well as time. Since the
problem is triply periodic, Fourier exponentials are normally the best choice
for trial and test functions, and as such we use basis functions 

$$
\begin{equation}
\phi_l(x) = e^{\imath \underline{l} x}, \quad -\infty < l < \infty,
\tag{11}
\end{equation}
$$

where \( l \) is the wavenumber, and
\( \underline{l}=\frac{2\pi}{L}l \) is the scaled wavenumber, scaled with domain
length \( L \) (here \( 4\pi \)). Since we want to solve these equations on a computer, we need to choose
a finite number of test functions. A basis \( V^N \) can be defined as

$$
\begin{equation}
V^N(x) = \text{span} \{\phi_l(x)\}_{l\in \boldsymbol{l}}, \tag{12}
\end{equation}
$$

where \( N \) is chosen as an even positive integer and \( \boldsymbol{l} = (-N/2,
-N/2+1, \ldots, N/2-1) \). And now, since \( \Omega \) is a
three-dimensional domain, we can create Cartesian products of such bases to get,
e.g., for three dimensions

$$
\begin{equation}
W^{\boldsymbol{N}}(x, y, z) = V^N(x) \times V^N(y) \times V^N(z), \tag{13}
\end{equation}
$$

where \( \boldsymbol{N} = (N, N, N) \). Obviously, it is not necessary to use the
same number (\( N \)) of basis functions for each direction, but it is done here
for simplicity. A 3D tensor product basis function is now defined as

$$
\begin{equation}
\Phi_{l,m,n}(x,y,z) = e^{\imath \underline{l} x} e^{\imath \underline{m} y}
e^{\imath \underline{n} z} = e^{\imath
(\underline{l}x + \underline{m}y + \underline{n}z)}
\tag{14}
\end{equation}
$$

where the indices for \( y \)- and \( z \)-direction are \( \underline{m}=\frac{2\pi}{L}m,
\underline{n}=\frac{2\pi}{L}n \), and \( \boldsymbol{m} \) and \( \boldsymbol{n} \) are the same as
\( \boldsymbol{l} \) due to using the same number of basis functions for each direction. One
distinction, though, is that for the \( z \)-direction expansion coefficients are only stored for
\( n=(0, 1, \ldots, N/2) \) due to Hermitian symmetry (real input data).

<p>
We now look for solutions of the form

$$
\begin{equation}
u(x, y, z) = \sum_{n=-N/2}^{N/2-1}\sum_{m=-N/2}^{N/2-1}\sum_{l=-N/2}^{N/2-1}
\hat{u}_{l,m,n} \Phi_{l,m,n}(x,y,z). 
\tag{15}
\end{equation}
$$

<p>
The expansion coefficients \( \hat{u}_{l,m,n} \) can be related directly to the solution \( u(x,
y, z) \) using Fast Fourier Transforms (FFTs) if we are satisfied with obtaining
the solution in quadrature points corresponding to

$$
\begin{align}
 x_i &= \frac{4 \pi i}{N}-2\pi \quad \forall \, i \in \boldsymbol{i},
\text{where}\, \boldsymbol{i}=(0,1,\ldots,N-1), 
\tag{16}\\ 
 y_j &= \frac{4 \pi j}{N}-2\pi \quad \forall \, j \in \boldsymbol{j},
\text{where}\, \boldsymbol{j}=(0,1,\ldots,N-1), 
\tag{17}\\ 
 z_k &= \frac{4 \pi k}{N}-2\pi \quad \forall \, k \in \boldsymbol{k},
\text{where}\, \boldsymbol{k}=(0,1,\ldots,N-1). 
\tag{18}\\ 
\tag{19}
\end{align}
$$

Note that these points are different from the standard (like \( 2\pi j/N \)) since
the domain
is set to \( [-2\pi, 2\pi]^3 \) and not the more common \( [0, 2\pi]^3 \). We have

$$
\begin{equation}
u(x_i, y_j, z_k) =
N^3
\mathcal{F}_k^{-1}\left(\mathcal{F}_j^{-1}\left(\mathcal{F}_i^{-1}\left(\hat{u}\right)\right)\right)
\, \forall\, (i,j,k)\in\boldsymbol{i} \times \boldsymbol{j} \times
\boldsymbol{k},
\tag{20}
\end{equation}
$$

where \( \mathcal{F}_i^{-1} \) is the inverse Fourier transform along the direction
of index \( i \), for
all \( (j, k) \in \boldsymbol{j} \times \boldsymbol{k} \). Note that the three
inverse FFTs are performed sequentially, one direction at the time, and that the factor \( N^3 \) is due to
the definition used for the inverse Fourier transform, which is the one used
also by <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.fft.html" target="_self">Numpy</a>:

$$
\begin{equation}
u(x_j) = \frac{1}{N}\sum_{l=-N/2}^{N/2-1} \hat{u}_l e^{\imath \underline{l}
x_j}, \quad \,\, \forall \, j \in \, \boldsymbol{j}.
\tag{21}
\end{equation}
$$

<p>
The inner products used in Eqs. <a href="#mjx-eqn-9">(9)</a>, <a href="#mjx-eqn-10">(10)</a> may be
computed using forward FFTs:

$$
\begin{equation}
\left(u, \Phi_{l,m,n}\right) =
\left(\frac{2\pi}{N}\right)^3
\mathcal{F}_l\left(\mathcal{F}_m\left(\mathcal{F}_n\left({u}\right)\right)\right)
\quad \forall (l,m,n) \in \boldsymbol{l} \times \boldsymbol{m} \times
\boldsymbol{n},
\tag{22}
\end{equation}
$$

<p>
whereas a complete transform requires
$$
\begin{equation}
\hat{u}_{l,m,n} =
\left(\frac{1}{N}\right)^3
\mathcal{F}_l\left(\mathcal{F}_m\left(\mathcal{F}_n\left(u\right)\right)\right)
\quad \forall (l,m,n) \in \boldsymbol{l} \times \boldsymbol{m} \times
\boldsymbol{n}.
\tag{23}
\end{equation}
$$

<p>
From this we see that the variational forms <a href="#mjx-eqn-9">(9)</a> and <a href="#mjx-eqn-10">(10)</a>
may be written in terms of the Fourier transformed quantities \( \hat{u} \) and
\( \hat{f} \). Expanding the exact derivatives of the nabla operator, we have

$$
\begin{align}
(\nabla u, \nabla v) &=
(2\pi)^3(\underline{l}^2+\underline{m}^2+\underline{n}^2)\hat{u}_{l,m,n}, 
\tag{24}\\ 
(u, v) &= (2\pi)^3\hat{u}_{l,m,n}, 
\tag{25}\\ 
(u|u|^2, v) &= (2\pi)^3 \widehat{u|u|^2}
\tag{26}
\end{align}
$$

<p>
and as such the equations to be solved can be found directly as

$$
\begin{align}
\frac{\partial \hat{f}}{\partial t}  &=
\left(-(\underline{l}^2+\underline{m}^2+\underline{n}^2+\gamma)\hat{u} + \gamma \widehat{u|u|^2}\right), \tag{27} \\ 
\frac{\partial \hat{u}}{\partial t} &= \hat{f}. \tag{28}
\end{align}
$$

<p>
There is more than one way to arrive at these equations. Taking the 3D Fourier
transform of both equations  <a href="#mjx-eqn-5">(5)</a> and <a href="#mjx-eqn-6">(6)</a> is one obvious way.
With the Python module <a href="https://github.com/spectralDNS/shenfun" target="_self">shenfun</a>, one can work with the
inner products as seen in <a href="#mjx-eqn-9">(9)</a> and <a href="#mjx-eqn-10">(10)</a>, or the Fourier
transforms directly. See for example Sec. <a href="#sec:rk">Runge-Kutta integrator</a> for how \( (\nabla u, \nabla
v) \) can be
implemented.  In short, <code>shenfun</code> contains all the tools required to work with
the spectral Galerkin method, and we will now see how <code>shenfun</code> can be used to solve
the Klein-Gordon equation.

<p>
<!-- We simplify notation by writing three-dimensional inner products as -->
<!-- !bt -->
<!-- \begin{align} -->
<!-- (u, v) &= \mathcal{S}(u), \\ -->
<!-- &= \left(\frac{2\pi}{N}\right)^3 \mathcal{F}(u) -->
<!-- \end{align} -->
<!-- !et -->
<!-- and three-dimensional transforms as -->
<!-- !bt -->
<!-- \begin{align} -->
<!-- \hat{u} &= \mathcal{T}(u), \\ -->
<!-- &= \left(\frac{1}{N}\right)^3 \mathcal{F}(u) -->
<!-- \end{align} -->
<!-- !et -->
<!-- with inverse \( u = \mathcal{T}^{-1}(\hat{u}) \). -->

<h1 id="___sec4" class="anchor">Implementation </h1>

<p>
To solve the Klein-Gordon equations we need to make use of the Fourier bases in
<code>shenfun</code>, and these base are found in submodule
<code>shenfun.fourier.bases</code>.
The triply periodic domain allows for Fourier in all three directions, and we
can as such create one instance of the base class <code>C2CBasis</code>
for each direction (<code>C2C</code> here meaning complex to complex). However, since the initial data are real, we
can take advantage of Hermitian symmetries and thus make use of the
<code>R2CBasis</code>
(real to complex) class for one (but only one) of the directions. We can only make use of the
<code>R2CBasis</code> for the direction that we choose to transform first with the forward
FFT, and the reason is obviously that the output from a forward transform of
real data is now complex. We may start implementing the solver as follows

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">shenfun</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpi4py</span> <span style="color: #008000; font-weight: bold">import</span> MPI
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #408080; font-style: italic"># Set size of discretization</span>
N <span style="color: #666666">=</span> (<span style="color: #666666">32</span>, <span style="color: #666666">32</span>, <span style="color: #666666">32</span>)

<span style="color: #408080; font-style: italic"># Create bases</span>
K0 <span style="color: #666666">=</span> fourier<span style="color: #666666">.</span>bases<span style="color: #666666">.</span>C2CBasis(N[<span style="color: #666666">0</span>], domain<span style="color: #666666">=</span>(<span style="color: #666666">-2*</span>np<span style="color: #666666">.</span>pi, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi))
K1 <span style="color: #666666">=</span> fourier<span style="color: #666666">.</span>bases<span style="color: #666666">.</span>C2CBasis(N[<span style="color: #666666">1</span>], domain<span style="color: #666666">=</span>(<span style="color: #666666">-2*</span>np<span style="color: #666666">.</span>pi, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi))
K2 <span style="color: #666666">=</span> fourier<span style="color: #666666">.</span>bases<span style="color: #666666">.</span>R2CBasis(N[<span style="color: #666666">2</span>], domain<span style="color: #666666">=</span>(<span style="color: #666666">-2*</span>np<span style="color: #666666">.</span>pi, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi))
</pre></div>
<p>
We now have three instances <code>K0</code>, <code>K1</code> and <code>K2</code>, corresponding to the basis
<a href="#mjx-eqn-12">(12)</a>, that each can be used to solve
one-dimensional problems. However, we want to solve a 3D problem, and for this
we need a tensor product basis, like <a href="#mjx-eqn-13">(13)</a>, created as a Cartesian product of these three
bases

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># Create communicator</span>
comm <span style="color: #666666">=</span> MPI<span style="color: #666666">.</span>COMM_WORLD

T <span style="color: #666666">=</span> TensorProductSpace(comm, (K0, K1, K2), <span style="color: #666666">**</span>{<span style="color: #BA2121">&#39;planner_effort&#39;</span>: 
                                              <span style="color: #BA2121">&#39;FFTW_MEASURE&#39;</span>})
</pre></div>
<p>
Here the <code>planner_effort</code>, which is a flag used by <a href="http://www.fftw.org" target="_self">FFTW</a>, is optional. Possibel choices are from the list
(<code>FFTW_ESTIMATE</code>, <code>FFTW_MEASURE</code>, <code>FFTW_PATIENT</code>, <code>FFTW_EXHAUSTIVE</code>), and the
flag determines how much effort FFTW puts in looking for an optimal algorithm
for the current platform. Note that it is also possible to use FFTW <a href="http://www.fftw.org/fftw3_doc/Wisdom.html#Wisdom" target="_self">wisdom</a> with
<code>shenfun</code>, and as such, for production, one may perform exhaustive planning once
and then simply import the result of that planning later, as wisdom.

<p>
The <code>TensorProductSpace</code> instance <code>T</code> contains pretty much all we need for
computing inner products or fast transforms between real and wavenumber space.
However, since we are going to solve for a mixed system, it is convenient to also use the
<code>MixedTensorProductSpace</code> class

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>TT <span style="color: #666666">=</span> MixedTensorProductSpace([T, T])
</pre></div>
<p>
We need containers for the solution as well as intermediate work arrays for,
e.g., the Runge-Kutta method. Arrays are created as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>uf <span style="color: #666666">=</span> Array(TT, <span style="color: #008000">False</span>) <span style="color: #408080; font-style: italic"># Solution array in physical space</span>
u, f <span style="color: #666666">=</span> uf[:]          <span style="color: #408080; font-style: italic"># Split solution array by creating two views u and f</span>

duf <span style="color: #666666">=</span> Array(TT)       <span style="color: #408080; font-style: italic"># Array for right hand sides</span>
du, df <span style="color: #666666">=</span> duf[:]       <span style="color: #408080; font-style: italic"># Split into views</span>

uf_hat <span style="color: #666666">=</span> Array(TT)    <span style="color: #408080; font-style: italic"># Solution in spectral space</span>
uf_hat0 <span style="color: #666666">=</span> Array(TT)   <span style="color: #408080; font-style: italic"># Work array 1</span>
uf_hat1 <span style="color: #666666">=</span> Array(TT)   <span style="color: #408080; font-style: italic"># Work array 2</span>
u_hat, f_hat <span style="color: #666666">=</span> uf_hat[:] <span style="color: #408080; font-style: italic"># Split into views</span>
</pre></div>
<p>
The <code>Array</code> class is a subclass of Numpy's <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html" target="_self">ndarray</a>,
without much more functionality than constructors that return arrays of the
correct shape according to the basis used in the construction. A different type
of array is returned by the <code>Function</code>
class, that subclasses both Nympy's ndarray as well as an internal
<code>BasisFunction</code>
class. An instance of the <code>Function</code> class may be used as a regular array,
but also as an argument in forms. For example, if you want to compute the
partial derivative \( \partial u/\partial x \), then this may be achieved by
projection, i.e., find \( u_x \in V^N \) such that \( (u_x-\partial u/\partial x, v) = 0 \),
for all \( v \in V^N \). This projection may be easily computed in <code>shenfun</code> using

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>v <span style="color: #666666">=</span> Function(T, <span style="color: #008000">False</span>, <span style="color: #008000">buffer</span><span style="color: #666666">=</span>u)
ux <span style="color: #666666">=</span> project(Dx(v, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>), T)
</pre></div>
<p>
where <code>v</code> now is an instance of the <code>Function</code> class and not the
<code>Array</code>, like
<code>u</code>. The following code, on the other hand, will raise an error since you cannot
use the <code>Array u</code> in a form, like <code>Dx(u, 0, 1)</code>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">try</span>: 
    project(Dx(u, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>), T)
<span style="color: #008000; font-weight: bold">except</span> <span style="color: #D2413A; font-weight: bold">AssertionError</span>:
    <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;AssertionError: Dx not for Arrays&quot;</span>)
</pre></div>
<p>
Note that <code>u</code> and <code>v</code> share the same data, and changing one will as such also
change the other. The reason for having two classes is that regular indexing and
slicing is faster on a <em>smaller</em> <code>Array</code> class that is carrying less of the additional
information required by forms.

<h2 id="___sec5" class="anchor">Initialization </h2>

<p>
The solution arrays <code>uf</code> and its transform <code>uf_hat</code> need to be initialized according to Eq.
<a href="#mjx-eqn-2">(2)</a>. To this end it is convenient (but not required, we could just as
easily use Numpy for this as well) to use <a href="http://www.sympy.org/en/index.html" target="_self">Sympy</a>, which is a Python library for symbolic
mathamatics.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> symbols, exp, lambdify

x, y, z <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&quot;x,y,z&quot;</span>)
ue <span style="color: #666666">=</span> <span style="color: #666666">0.1*</span>exp(<span style="color: #666666">-</span>(x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> y<span style="color: #666666">**2</span> <span style="color: #666666">+</span> z<span style="color: #666666">**2</span>))
ul <span style="color: #666666">=</span> lambdify((x, y, z), ue, <span style="color: #BA2121">&#39;numpy&#39;</span>)
X <span style="color: #666666">=</span> T<span style="color: #666666">.</span>local_mesh(<span style="color: #008000">True</span>)
u[:] <span style="color: #666666">=</span> ul(<span style="color: #666666">*</span>X)
u_hat <span style="color: #666666">=</span> T<span style="color: #666666">.</span>forward(u, u_hat)
</pre></div>
<p>
Here <code>X</code> is a list of the three mesh coordinates <code>(x, y, z)</code> local to the
current processor. Each processor has its own part of the computational mesh,
and the distribution is handled during the creation of the
<code>TensorProductSpace</code>
class instance <code>T</code>. There is no need
to do anything about the <code>f/f_hat</code> arrays since they are already initialized by default to
zero. Note that calling the <code>ul</code> function with the argument <code>*X</code> is the same as
calling with <code>X[0], X[1], X[2]</code>.

<h2 id="sec:rk" class="anchor">Runge-Kutta integrator</h2>
A fourth order explicit Runge-Kutta integrator requires only a function that
returns the right hand sides of <a href="#mjx-eqn-27">(27)</a> and <a href="#mjx-eqn-28">(28)</a>. Such a
function can be implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic"># focusing (+1) or defocusing (-1)</span>
gamma <span style="color: #666666">=</span> <span style="color: #666666">1</span>  
uh <span style="color: #666666">=</span> TrialFunction(T)
vh <span style="color: #666666">=</span> TestFunction(T)i
A <span style="color: #666666">=</span> inner(vh, uh)
k2 <span style="color: #666666">=</span> <span style="color: #666666">-</span>(inner(grad(vh), grad(uh)) <span style="color: #666666">/</span> A <span style="color: #666666">+</span> gamma)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compute_rhs</span>(duf_hat, uf_hat, up, Tp, w0):
    duf_hat<span style="color: #666666">.</span>fill(<span style="color: #666666">0</span>)
    u_hat, f_hat <span style="color: #666666">=</span> uf_hat[:]
    du_hat, df_hat <span style="color: #666666">=</span> duf_hat[:]
    df_hat[:] <span style="color: #666666">=</span> k2<span style="color: #666666">*</span>u_hat
    up <span style="color: #666666">=</span> Tp<span style="color: #666666">.</span>backward(u_hat, up)
    df_hat <span style="color: #666666">+=</span> Tp<span style="color: #666666">.</span>forward(gamma<span style="color: #666666">*</span>up<span style="color: #666666">**3</span>, w0)
    du_hat[:] <span style="color: #666666">=</span> f_hat
    <span style="color: #008000; font-weight: bold">return</span> duf_hat
</pre></div>
<p>
The code is fairly self-explanatory. <code>k2</code> represents the coefficients in front of
the linear \( \hat{u} \) in <a href="#mjx-eqn-27">(27)</a>. The output array is <code>duf_hat</code>, and
the input array is <code>uf_hat</code>, whereas <code>up</code> and <code>w0</code> are work arrays. The array
<code>duf_hat</code> contains the right hand sides of both <a href="#mjx-eqn-27">(27)</a> and
<a href="#mjx-eqn-28">(28)</a>, where the linear and nonlinear terms are recognized in the
code as comments <code>(1)</code> and <code>(2)</code>.
The array <code>uf_hat</code> contains the solution at initial and intermediate Runge-Kutta steps.

<p>
With a function that returns the right hand side in place, the actual integrator
can be implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>w0 <span style="color: #666666">=</span> Array(T)
a <span style="color: #666666">=</span> [<span style="color: #666666">1./6.</span>, <span style="color: #666666">1./3.</span>, <span style="color: #666666">1./3.</span>, <span style="color: #666666">1./6.</span>]         <span style="color: #408080; font-style: italic"># Runge-Kutta parameter</span>
b <span style="color: #666666">=</span> [<span style="color: #666666">0.5</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1.</span>]                       <span style="color: #408080; font-style: italic"># Runge-Kutta parameter</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0</span>
dt <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
end_time <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;</span> end_time<span style="color: #666666">-1e-8</span>:
    t <span style="color: #666666">+=</span> dt
    uf_hat1[:] <span style="color: #666666">=</span> uf_hat0[:] <span style="color: #666666">=</span> uf_hat
    <span style="color: #008000; font-weight: bold">for</span> rk <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">4</span>):
        duf <span style="color: #666666">=</span> compute_rhs(duf, uf_hat, u, T, w0)
        <span style="color: #008000; font-weight: bold">if</span> rk <span style="color: #666666">&lt;</span> <span style="color: #666666">3</span>:
            uf_hat[:] <span style="color: #666666">=</span> uf_hat0 <span style="color: #666666">+</span> b[rk]<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>duf
        uf_hat1 <span style="color: #666666">+=</span> a[rk]<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>duf
    uf_hat[:] <span style="color: #666666">=</span> uf_hat1
</pre></div>

<h2 id="sec:solver" class="anchor">Complete solver</h2>

<p>
A complete solver is given below, with intermediate plotting of the solution and
intermediate computation of the total energy. Note that the total energy is unchanged to 8
decimal points at \( t=100 \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> symbols, exp, lambdify
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpi4py</span> <span style="color: #008000; font-weight: bold">import</span> MPI
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">time</span> <span style="color: #008000; font-weight: bold">import</span> time
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">shenfun.fourier.bases</span> <span style="color: #008000; font-weight: bold">import</span> R2CBasis, C2CBasis
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">shenfun</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

comm <span style="color: #666666">=</span> MPI<span style="color: #666666">.</span>COMM_WORLD
rank <span style="color: #666666">=</span> comm<span style="color: #666666">.</span>Get_rank()

<span style="color: #408080; font-style: italic"># Use sympy to set up initial condition</span>
x, y, z <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&quot;x,y,z&quot;</span>)
ue <span style="color: #666666">=</span> <span style="color: #666666">0.1*</span>exp(<span style="color: #666666">-</span>(x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> y<span style="color: #666666">**2</span> <span style="color: #666666">+</span> z<span style="color: #666666">**2</span>))
ul <span style="color: #666666">=</span> lambdify((x, y, z), ue, <span style="color: #BA2121">&#39;numpy&#39;</span>)

<span style="color: #408080; font-style: italic"># Size of discretization</span>
N <span style="color: #666666">=</span> (<span style="color: #666666">64</span>, <span style="color: #666666">64</span>, <span style="color: #666666">64</span>)

<span style="color: #408080; font-style: italic"># Defocusing or focusing</span>
gamma <span style="color: #666666">=</span> <span style="color: #666666">1</span>

K0 <span style="color: #666666">=</span> C2CBasis(N[<span style="color: #666666">0</span>], domain<span style="color: #666666">=</span>(<span style="color: #666666">-2*</span>np<span style="color: #666666">.</span>pi, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi))
K1 <span style="color: #666666">=</span> C2CBasis(N[<span style="color: #666666">1</span>], domain<span style="color: #666666">=</span>(<span style="color: #666666">-2*</span>np<span style="color: #666666">.</span>pi, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi))
K2 <span style="color: #666666">=</span> R2CBasis(N[<span style="color: #666666">2</span>], domain<span style="color: #666666">=</span>(<span style="color: #666666">-2*</span>np<span style="color: #666666">.</span>pi, <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi))
T <span style="color: #666666">=</span> TensorProductSpace(comm, (K0, K1, K2), slab<span style="color: #666666">=</span><span style="color: #008000">False</span>, <span style="color: #666666">**</span>{<span style="color: #BA2121">&#39;planner_effort&#39;</span>: <span style="color: #BA2121">&#39;FFTW_MEASURE&#39;</span>})

TT <span style="color: #666666">=</span> MixedTensorProductSpace([T, T])

X <span style="color: #666666">=</span> T<span style="color: #666666">.</span>local_mesh(<span style="color: #008000">True</span>)
uf <span style="color: #666666">=</span> Array(TT, <span style="color: #008000">False</span>)
u, f <span style="color: #666666">=</span> uf[:]
up <span style="color: #666666">=</span> Array(T, <span style="color: #008000">False</span>)

duf <span style="color: #666666">=</span> Array(TT)
du, df <span style="color: #666666">=</span> duf[:]

uf_hat <span style="color: #666666">=</span> Array(TT)
uf_hat0 <span style="color: #666666">=</span> Array(TT)
uf_hat1 <span style="color: #666666">=</span> Array(TT)
w0 <span style="color: #666666">=</span> Array(T)
u_hat, f_hat <span style="color: #666666">=</span> uf_hat[:]

<span style="color: #408080; font-style: italic"># initialize (f initialized to zero, so all set)</span>
u[:] <span style="color: #666666">=</span> ul(<span style="color: #666666">*</span>X)
u_hat <span style="color: #666666">=</span> T<span style="color: #666666">.</span>forward(u, u_hat)

uh <span style="color: #666666">=</span> TrialFunction(T)
vh <span style="color: #666666">=</span> TestFunction(T)
A <span style="color: #666666">=</span> inner(uh, vh)
k2 <span style="color: #666666">=</span> <span style="color: #666666">-</span>inner(grad(vh), grad(uh)) <span style="color: #666666">/</span> A <span style="color: #666666">-</span> gamma

count <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compute_rhs</span>(duf_hat, uf_hat, up, T, w0):
    <span style="color: #008000; font-weight: bold">global</span> count
    count <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    duf_hat<span style="color: #666666">.</span>fill(<span style="color: #666666">0</span>)
    u_hat, f_hat <span style="color: #666666">=</span> uf_hat[:]
    du_hat, df_hat <span style="color: #666666">=</span> duf_hat[:]
    df_hat[:] <span style="color: #666666">=</span> k2<span style="color: #666666">*</span>u_hat
    up <span style="color: #666666">=</span> T<span style="color: #666666">.</span>backward(u_hat, up)
    df_hat <span style="color: #666666">+=</span> T<span style="color: #666666">.</span>forward(gamma<span style="color: #666666">*</span>up<span style="color: #666666">**3</span>, w0)
    du_hat[:] <span style="color: #666666">=</span> f_hat
    <span style="color: #008000; font-weight: bold">return</span> duf_hat

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">energy_fourier</span>(comm, a):
    result <span style="color: #666666">=</span> <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>sum(<span style="color: #008000">abs</span>(a[<span style="color: #666666">...</span>, <span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])<span style="color: #666666">**2</span>) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>sum(<span style="color: #008000">abs</span>(a[<span style="color: #666666">...</span>, <span style="color: #666666">0</span>])<span style="color: #666666">**2</span>) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>sum(<span style="color: #008000">abs</span>(a[<span style="color: #666666">...</span>, <span style="color: #666666">-1</span>])<span style="color: #666666">**2</span>)
    result <span style="color: #666666">=</span>  comm<span style="color: #666666">.</span>allreduce(result)
    <span style="color: #008000; font-weight: bold">return</span> result

<span style="color: #408080; font-style: italic"># Integrate using a 4th order Rung-Kutta method</span>
a <span style="color: #666666">=</span> [<span style="color: #666666">1./6.</span>, <span style="color: #666666">1./3.</span>, <span style="color: #666666">1./3.</span>, <span style="color: #666666">1./6.</span>]         <span style="color: #408080; font-style: italic"># Runge-Kutta parameter</span>
b <span style="color: #666666">=</span> [<span style="color: #666666">0.5</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1.</span>]                       <span style="color: #408080; font-style: italic"># Runge-Kutta parameter</span>
t <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
dt <span style="color: #666666">=</span> <span style="color: #666666">0.005</span>
end_time <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
tstep <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">if</span> rank <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
    plt<span style="color: #666666">.</span>figure()
    image <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>contourf(X[<span style="color: #666666">1</span>][<span style="color: #666666">...</span>, <span style="color: #666666">0</span>], X[<span style="color: #666666">0</span>][<span style="color: #666666">...</span>, <span style="color: #666666">0</span>], u[<span style="color: #666666">...</span>, <span style="color: #666666">16</span>], <span style="color: #666666">100</span>)
    plt<span style="color: #666666">.</span>draw()
    plt<span style="color: #666666">.</span>pause(<span style="color: #666666">1e-4</span>)
t0 <span style="color: #666666">=</span> time()
K <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(T<span style="color: #666666">.</span>local_wavenumbers(<span style="color: #008000">True</span>, <span style="color: #008000">True</span>, <span style="color: #008000">True</span>))
TV <span style="color: #666666">=</span> VectorTensorProductSpace([T, T, T])
gradu <span style="color: #666666">=</span> Array(TV, <span style="color: #008000">False</span>)
<span style="color: #008000; font-weight: bold">while</span> t <span style="color: #666666">&lt;</span> end_time<span style="color: #666666">-1e-8</span>:
    t <span style="color: #666666">+=</span> dt
    tstep <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    uf_hat1[:] <span style="color: #666666">=</span> uf_hat0[:] <span style="color: #666666">=</span> uf_hat
    <span style="color: #008000; font-weight: bold">for</span> rk <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">4</span>):
        duf <span style="color: #666666">=</span> compute_rhs(duf, uf_hat, up, T, w0)
        <span style="color: #008000; font-weight: bold">if</span> rk <span style="color: #666666">&lt;</span> <span style="color: #666666">3</span>:
            uf_hat[:] <span style="color: #666666">=</span> uf_hat0 <span style="color: #666666">+</span> b[rk]<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>duf
        uf_hat1 <span style="color: #666666">+=</span> a[rk]<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>duf
    uf_hat[:] <span style="color: #666666">=</span> uf_hat1

    <span style="color: #008000; font-weight: bold">if</span> tstep <span style="color: #666666">%</span> <span style="color: #666666">100</span> <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
        uf <span style="color: #666666">=</span> TT<span style="color: #666666">.</span>backward(uf_hat, uf)
        ekin <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>energy_fourier(T<span style="color: #666666">.</span>comm, f_hat)
        es <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>energy_fourier(T<span style="color: #666666">.</span>comm, <span style="color: #666666">1j*</span>K<span style="color: #666666">*</span>u_hat)
        eg <span style="color: #666666">=</span> gamma<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sum(<span style="color: #666666">0.5*</span>u<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">0.25*</span>u<span style="color: #666666">**4</span>)<span style="color: #666666">/</span>np<span style="color: #666666">.</span>prod(np<span style="color: #666666">.</span>array(N))
        eg <span style="color: #666666">=</span>  comm<span style="color: #666666">.</span>allreduce(eg)
        gradu <span style="color: #666666">=</span> TV<span style="color: #666666">.</span>backward(<span style="color: #666666">1j*</span>K<span style="color: #666666">*</span>u_hat, gradu)
        ep <span style="color: #666666">=</span> comm<span style="color: #666666">.</span>allreduce(np<span style="color: #666666">.</span>sum(f<span style="color: #666666">*</span>gradu)<span style="color: #666666">/</span>np<span style="color: #666666">.</span>prod(np<span style="color: #666666">.</span>array(N)))
        ea <span style="color: #666666">=</span> comm<span style="color: #666666">.</span>allreduce(np<span style="color: #666666">.</span>sum(np<span style="color: #666666">.</span>array(X)<span style="color: #666666">*</span>(<span style="color: #666666">0.5*</span>f<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>gradu<span style="color: #666666">**2</span> <span style="color: #666666">-</span> (<span style="color: #666666">0.5*</span>u<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">0.25*</span>u<span style="color: #666666">**4</span>)<span style="color: #666666">*</span>f))<span style="color: #666666">/</span>np<span style="color: #666666">.</span>prod(np<span style="color: #666666">.</span>array(N)))
        <span style="color: #008000; font-weight: bold">if</span> rank <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            image<span style="color: #666666">.</span>ax<span style="color: #666666">.</span>clear()
            image<span style="color: #666666">.</span>ax<span style="color: #666666">.</span>contourf(X[<span style="color: #666666">1</span>][<span style="color: #666666">...</span>, <span style="color: #666666">0</span>], X[<span style="color: #666666">0</span>][<span style="color: #666666">...</span>, <span style="color: #666666">0</span>], u[<span style="color: #666666">...</span>, <span style="color: #666666">16</span>], <span style="color: #666666">100</span>)
            plt<span style="color: #666666">.</span>pause(<span style="color: #666666">1e-6</span>)
            plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;Klein_Gordon_{}_real_{}.png&#39;</span><span style="color: #666666">.</span>format(N[<span style="color: #666666">0</span>], tstep))
            <span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;Time = </span><span style="color: #BB6688; font-weight: bold">%2.2f</span><span style="color: #BA2121"> Total energy = </span><span style="color: #BB6688; font-weight: bold">%2.8e</span><span style="color: #BA2121"> Linear momentum </span><span style="color: #BB6688; font-weight: bold">%2.8e</span><span style="color: #BA2121"> Angular momentum </span><span style="color: #BB6688; font-weight: bold">%2.8e</span><span style="color: #BA2121">&quot;</span> <span style="color: #666666">%</span>(t, ekin<span style="color: #666666">+</span>es<span style="color: #666666">+</span>eg, ep, ea))
        comm<span style="color: #666666">.</span>barrier()

<span style="color: #008000; font-weight: bold">print</span>(<span style="color: #BA2121">&quot;Time &quot;</span>, time()<span style="color: #666666">-</span>t0)
</pre></div>

<h1 id="___sec8" class="anchor">Bibliography </h1>

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="abdul08"></div> <b>A.-M. Wazwaz</b>. 
    New Travelling Wave Solutions to the Boussinesq and the Klein-Gordon Equations,
    <em>Communications in Nonlinear Science and Numerical Simulation</em>,
    13(5),
    pp. 889-901,
    <a href="http://dx.doi.org/http://dx.doi.org/10.1016/j.cnsns.2006.08.005" target="_self">doi: http://dx.doi.org/10.1016/j.cnsns.2006.08.005</a>,
    2008,
    <a href="http://www.sciencedirect.com/science/article/pii/S1007570406001729" target="_self"><tt>http://www.sciencedirect.com/science/article/pii/S1007570406001729</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright --> &copy; 2018, Mikael Mortensen. Released under CC Attribution 4.0 license
</center>


</body>
</html>
    

